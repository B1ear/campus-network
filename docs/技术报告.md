# 校园网络算法可视化平台 技术报告

作者：项目团队
日期：2025-11-02
版本：v2.0

---



## 1. 项目概述

### 1.1 项目简介

本项目是一个全功能的前后端分离的“校园网络算法可视化平台”，提供以下核心功能：

**核心算法实现：**
- 🌲 **最小生成树 (MST)**: Kruskal 与 Prim 算法的完整实现与性能对比
- 💧 **最大流 (Max-Flow)**: Edmonds-Karp 与 Dinic 算法的分层对比
- 🔐 **AES-128 加密**: 完整的加密/解密实现

**网络仿真功能：**
- 🌐 **智能网络生成**: 随机连通平面图生成器
- 🎮 **交互式仿真**: 实时流量可视化与拥塞控制
- 📊 **负载均衡**: 多路径查找与容量感知分配
- 🚦 **拥塞检测**: 80%利用率阈值的智能路径选择

**可视化特性：**
- 🎬 **步骤动画**: 算法执行过程的逐步可视化
- 📈 **实时统计**: 性能指标和网络状态监控
- 🎨 **双端渲染**: 服务端 Matplotlib + 客户端 SVG

### 1.2 技术架构

**前端技术栈：**
- Vue 3 Composition API - 现代化响应式框架
- Vite 5.0 - 高性能构建工具
- 原生 SVG - 客户端动态可视化
- provide/inject - 轻量级状态管理

**后端技术栈：**
- Flask 3.0 - RESTful API 框架
- NetworkX 3.2.1 - 图算法库
- Matplotlib 3.8.2 - 服务端图像生成
- NumPy 1.26.2 - 数值计算库

### 1.3 项目亮点

1. **教学友好**: 完整的算法步骤可视化，适合课堂演示
2. **性能基准**: 算法计时与可视化计时分离，准确对比
3. **实时仿真**: SVG 动画 + 粒子系统模拟流量传输
4. **智能路由**: 基于利用率的动态权重调整
5. **完整文档**: 详尽的API文档和使用指南

---

## 2. 系统架构与技术栈

- 前端（frontend/）
  - 框架：Vue 3、Vite
  - 组件：
    - App.vue（总布局与 Tab 切换，provide/inject 全局网络）
    - NetworkConfigPanel.vue（网络配置/生成/预览/应用）
    - MSTPanel.vue（MST 对比 + 步骤动画 + 结果可视化）
    - MaxFlowPanel.vue（EK/Dinic 对比 + 步骤动画 + 结果可视化）
    - InteractiveTrafficPanel.vue（交互式仿真：路径、分配、SVG 动画）
    - AESPanel.vue（AES-128 加密/解密）
    - 通用组件：EdgeEditor.vue、AnimationPlayer.vue、ImageViewer.vue、Toast.vue
  - API 封装：src/api/backend.js

- 后端（backend/）
  - Flask 应用：app.py（REST API 路由、参数校验、聚合输出）
  - 算法模块：
    - algorithms/maxflow.py（EK、Dinic 实现 + 步骤可视化对接）
    - algorithms/mst.py（Kruskal、Prim + 步骤可视化）
    - algorithms/traffic.py（多路径负载均衡、拥塞检测、简化仿真接口）
    - algorithms/generate_graph.py（连通平面图生成与绘制）
    - algorithms/utils.py（通用校验、固定布局、绘图导出/样式/字体）
    - algorithms/aes_encrypt.py（AES-128 实现，app.py 通过 AES128 使用）
  - 配置：config/network_config.py（默认配置与参数校验）
  - 依赖：Flask、flask-cors、networkx、matplotlib、numpy

---

## 3. 数据模型与接口设计

- 图数据（前后端统一）：
  - 节点：[{ id, label? }]
  - 边：[{ from, to, weight?, cost?, capacity? }]
  - 说明：MST 使用 weight/cost；最大流使用 capacity；原始图预览优先显示 capacity，否则显示 weight/cost。

- 核心 API（已对齐前端）：
  - POST /api/network/generate → 随机生成拓扑（含 stats 与 base64 图像）
  - GET  /api/network/config/default → 获取默认网络配置
  - POST /api/graph/preview → 原始图预览（base64）
  - POST /api/mst/compare → Kruskal 与 Prim 对比（steps、viz）
  - POST /api/maxflow/edmonds-karp → EK 最大流（steps、viz）
  - POST /api/maxflow/dinic → Dinic 最大流（steps、viz）
  - POST /api/aes/encrypt、/api/aes/decrypt（hex 格式）
  - POST /api/traffic/calculate-paths → 路径与流量分配（交互仿真）

---

## 4. 后端模块实现要点

### 4.1 app.py（路由层）
- 统一进行参数解析与 validate_graph_data 校验
- 将 nodes/edges 转换为算法所需形态（如 EK/Dinic 的“(u,v,cap)”字符串、MST 的 (u,v,w)）
- 聚合算法输出：
  - 含 max_flow、flow_edges、time、steps（带 Base64 PNG 可视化）
  - MST 与 Max-Flow 都提供步骤级可视化帧，前端 AnimationPlayer 播放
- 网络生成：调用 generate_random_planar_network → draw_campus_network（Base64）

### 4.2 algorithms/maxflow.py（最大流）
- 输入解析：parse_directed_input → [(u,v,w)]
- 残量图构建：build_capacity_graph → capacity[(u,v)]、adj[u] 列表、orig_caps
- Edmonds–Karp：edmonds_karp
  - BFS 在残量图上找最短增广路径（parent/bottleneck）
  - 更新残量：capacity[(u,v)] -= inc，capacity[(v,u)] += inc
  - return_steps 时：
    - compute_fixed_layout 固定布局（避免抖动）
    - 每次增广生成一帧 draw_maxflow_step_visualization（高亮当前路径、累计历史路径）
    - 结束帧 draw_maxflow_result（边宽按流量）
  - 时间复杂度：O(V·E²)
- Dinic：class Dinic
  - 邻接存边对（i 与 i^1 为正/反向边），edges: [u,v,cap]
  - bfs_level 构建层次图 level；dfs_flow 在层次图上送阻塞流（it 指针优化）
  - return_steps 时：
    - 开始/层次图帧、每条增广路径帧（标注瓶颈/饱和边）、阶段完成帧、最终帧（draw_maxflow_result）
  - 复杂度：一般 O(E·V²)，在单位网络等情况下更优（如 O(E·√V)）
- 统一对比主函数 main：运行 EK 与 Dinic，统计 time/maxflow/flows，并支持 steps 回传。

### 4.3 algorithms/traffic.py（交互式仿真：负载均衡）
- LoadBalancer
  - _build_graph：将无向边双向加入 DiGraph，边属性包含 weight/capacity/cost
  - find_k_shortest_paths(source, target, k)
    - 第 1 条：nx.shortest_path(weight='weight')
    - 策略1（边不相交）：移除已用边在副本上再次最短路
    - 策略2（惩罚复用边）：对已用边提升 weight（原重 × (1 + penalty×10)）以促进多样化
- calculate_paths_with_allocation（交互仿真实际使用的接口）
  - 输入：nodes、edges、source、target、total_flow、strategy('single'|'balanced')、num_paths
  - 路径：find_k_shortest_paths → 得到 paths
  - 能力：对每条 path 取瓶颈容量 min(cap) → path_capacities
  - 分配：
    - single：将 actual_flow（受总容量上限）尽量放到第一条路径，不超过其瓶颈
    - balanced：按各路径瓶颈容量占总容量比例分配（并不超过各自瓶颈）
  - 输出：paths、path_allocations[{flow, capacity, utilization}]、total_capacity、requested_flow、actual_flow、is_limited、num_paths
- CongestionController（可扩展）
  - detect_congestion：基于 utilization 与阈值分类拥塞/预警链路
  - suggest_rerouting：临时移除拥塞链路，按 capacity 作为“代价”尝试找替代路径
- simulate_traffic_load_balancing：历史保留的更完整仿真（含 JSON 序列化修复），前端未直接使用。

### 4.4 algorithms/mst.py（最小生成树）
- prim_mst：增量选边（维护 selected 集）；支持 return_steps，并以 draw_mst_step_visualization 输出过程帧。
- kruskal_mst：并查集判环；按权重排序；同样提供步骤级可视化。
- compare_mst_algorithms：重复测量时间对比；
- 与前端对接：/api/mst/compare 同时返回两种算法的 steps 与最终可视化图。

### 4.5 algorithms/generate_graph.py（拓扑生成）
- generate_random_planar_network：
  - 先构造随机生成树保证连通，再尝试添加若干额外边并用 nx.check_planarity 保持平面性
  - 设置 cost/capacity，生成 pos（随机极坐标+最小距离约束）
- draw_campus_network：大画布 + 白底标签，输出“cost/capacity”叠加的 Base64 图

### 4.6 algorithms/utils.py（工具与可视化）
- validate_graph_data：统一校验 nodes/edges 字段与引用正确性
- setup_chinese_font：中文字体与负号支持，统一图像风格（蓝紫主题）
- draw_original_graph：原始图（label_mode：capacity/cost/auto）
- draw_mst_step_visualization / draw_mst_result：MST 步骤/结果
- draw_maxflow_step_visualization / draw_dinic_step_visualization：最大流步骤帧（固定布局、历史路径/层次图/瓶颈/饱和边）
- draw_maxflow_result：最终流量分配（边宽随流量）
- draw_traffic_load_balancing：为扩展保留的多路径流量可视化

### 4.7 config/network_config.py
- DEFAULT_CONFIG：{ num_nodes, cost_range, capacity_range, seed }
- NetworkConfig：参数读入与 _validate 校验；to_dict / from_dict / default

---

## 5. 最大流算法专题（Edmonds–Karp vs Dinic）

### 5.1 Edmonds–Karp（BFS Ford–Fulkerson）
- 核心思想：在残量图上使用 BFS 寻找最短（按边数）增广路径，沿路径增广至瓶颈，直至不存在增广路径。
- 关键结构：
  - capacity[(u,v)] 残量；adj[u] 邻接；parent 回溯路径；bottleneck 记录路径最小残量
- 伪流程：
  1) BFS 找到 parent 与 bottleneck
  2) 若无路径 → 结束；否则沿 parent 回溯得到 path
  3) 沿 path 推流（更新 capacity 与反向边）
  4) 记录一步（可视化：红色高亮 path，累积历史路径淡蓝）
- 可视化：
  - 初始化帧：标注源/汇与原始容量
  - 增广帧：当前路径 + 瓶颈值 + 历史路径叠加
  - 结束帧：根据初始容量与最终残量反推每条边的流量，生成总览图
- 复杂度：O(V·E²)

### 5.2 Dinic（分层阻塞流）
- 核心思想：分阶段进行；每阶段：
  1) BFS 生成层次图 level（只允许从 i 层到 i+1 层）
  2) 在层次图上用 DFS 寻找阻塞流，直至无法再增广
  3) 若无法到达汇点，算法结束
- 关键结构：
  - edges 数组 + 反向边索引 i^1；level 字典；it[u] 当前边游标
- 可视化：
  - 层次图帧：高亮层次边/节点（按层渐变色）
  - 增广帧：当前路径（红）+ 饱和边（橙）+ 本阶段增量
  - 阶段完成帧：本阶段累计增量；最终帧同 EK
- 复杂度：一般 O(E·V²)，在许多实际网络更快（如单位容量网络 O(E·√V)）。

### 5.3 综合对比与前端展示
- app 的 maxflow_main 同时运行两种算法，输出 maxflow/time/flows/steps
- 前端 MaxFlowPanel：
  - 并列展示两者耗时与最大流、结果图片、流量边列表
  - AnimationPlayer 分别播放两者步骤帧
  - 校验提示：两算法最大流是否一致；更快者标记 🏆

---

## 6. 交互式仿真与负载均衡实现

### 6.1 目标与输入
- 在给定拓扑、源/目标、请求总流量 total_flow 下，找 k 条“较短且分散”的路径，并按容量进行分配；展示“活跃链路、利用率、拥塞”等动态指标。
- 请求体：nodes、edges、source、target、total_flow、strategy('single'|'balanced')、num_paths

### 6.2 路径发现（多路径）
- LoadBalancer.find_k_shortest_paths：
  - 先求最短路（权重 = edge.weight）
  - 策略1：从图中移除已用边，尽量获得边不相交多路径
  - 若仍不足 k：策略2 对已用边施加逐次惩罚（weight *= 1 + 使用次数×10），鼓励多样化
- 说明：该策略简单高效、可解释性强，适合教学演示；若追求最优 k 条路径，可替换为 Yen/K-Shortest Paths 等算法。

### 6.3 流量分配（容量感知）
- 对每条路径计算瓶颈容量（路径上所有边 capacity 的最小值）
- 计算 total_capacity = Σ 瓶颈
- actual_flow = min(total_flow, total_capacity)，is_limited 表示是否受容量限制
- 分配策略：
  - single：只用第 1 条路径，flow = min(actual_flow, path_capacity[0])
  - balanced：按各路径瓶颈容量占比对 actual_flow 进行比例分配（每条不超过其瓶颈）
- 输出 path_allocations：[{ flow, capacity, utilization=flow/capacity }]

### 6.4 前端可视化与动画

**InteractiveTrafficPanel 组件详解：**

1. **SVG 画布系统**
   - 力导向布局算法（自实现，固定随机种子）
   - ViewBox 动态调整支持缩放和平移
   - 响应式画布大小适配

2. **边的可视化**
   - 颜色语义：灰色(空闲) → 蓝色(活跃) → 红色(拥塞>80%)
   - 宽度反映利用率：1-5px 动态调整
   - 箭头标记：区分普通、活跃、拥塞链路
   - 支持双向边（无向图模式）

3. **粒子系统**
   - CSS animateMotion 实现流量动画
   - 粒子数量与流量大小成正比
   - 暂停/继续控制动画播放

4. **节点显示**
   - 颜色区分：源点(绿)、目标点(红)、普通点(蓝)
   - 大小反映重要性（源/汇节点更大）
   - 实时吞吐量数值显示
   - 鼠标悬停显示详细信息

5. **实时统计面板**
   - 已传输总量：累计流量计数
   - 平均利用率：所有活跃边的利用率均值
   - 活跃路径数：当前使用的路径数量
   - 拥塞链路数：利用率>80%的边数

6. **交互控制**
   - 开始/暂停/继续/重置按钮
   - 画布平移：鼠标拖拽
   - 画布缩放：鼠标滚轮
   - Toast 通知：操作反馈和错误提示

7. **状态管理**
   - `edgeUsageMap`: 跟踪每条边的当前流量
   - 多次计算时传递给后端实现累积
   - 重置时清空所有累积状态

### 6.5 拥塞检测与重路由建议（可扩展）
- CongestionController.detect_congestion：遍历 traffic_data，按阈值分类拥塞/预警
- suggest_rerouting：临时移除拥塞边，依据 capacity 作为“代价”寻找替代路径给出建议
- 当前前端未直接接入该扩展能力，可作为二辩/答辩中的拓展方向展示。

---

## 7. 前端模块与交互流程

- App.vue：侧边 Tab 切换；provide('globalNetwork'), provide('setGlobalNetwork')，实现全局网络共享
- backend.js：封装后端 API；统一错误处理
- NetworkConfigPanel：
  - 自动模式：调用 /network/generate 并二次 /graph/preview 生成高清图；结果保存 localStorage 并通过 setGlobalNetwork 提供给其他面板
  - 手动模式：内置边编辑器（造价+容量），同样通过 previewGraph 生成预览
- MSTPanel：
  - 文本/可视化两种输入模式；EdgeEditor 支持权重（造价）编辑；/mst/compare 返回 steps+viz 并播放动画
- MaxFlowPanel：
  - 文本/可视化两种输入；支持源/汇设置；/maxflow/edmonds-karp 与 /maxflow/dinic 并行请求、对比结果与动画
- InteractiveTrafficPanel：
  - 从 globalNetwork 获取拓扑，设定源/目标/策略/速率；
  - 调用 /traffic/calculate-paths 获取 paths + allocations；
  - 在 SVG 中持续动画，展示利用率、拥塞、吞吐量与统计
- 通用组件：
  - AnimationPlayer：播放 steps 帧（支持速度、放大查看仍可跟随播放）
  - ImageViewer：带遮罩与播放控制的大图查看
  - EdgeEditor：统一的边编辑控件（支持权重/容量）
  - Toast：统一提示组件

---

## 8. 可视化设计与一致性

- 后端全部使用 Matplotlib（Agg）与统一主题/字体（含中文字体回退）
- 固定随机种子 + compute_fixed_layout 保证步骤帧位置一致、避免“跳动”
- 颜色语义：
  - 源点绿色、汇点红色、普通节点蓝色
  - 当前路径红色、历史路径淡蓝、层次图深浅蓝、饱和边橙色
  - MST：候选边黄、已选边绿、当前边红
- 前端预览与后端可视化风格统一（白底标签、圆角边框、阴影等）

---

## 9. 测试与验证

- test/test_api.py：调用 /traffic/calculate-paths 的样例请求，验证 API 通路与 JSON 返回结构
- test/test_json_fix.py：验证仿真结果的 JSON 可序列化性（历史接口 simulate_traffic_load_balancing）
- 前端面板：
  - 内置“示例数据”、“加载配置网络”按钮，降低试用与演示成本
  - 动画步骤可视化直观呈现算法过程，辅助口头解释

---

## 10. 运行与部署

- 后端：
  - cd backend && pip install -r requirements.txt && python app.py
  - 默认 http://localhost:5000
- 前端：
  - cd frontend && npm install && npm run dev
  - 默认 http://localhost:3000
- 跨域：已启用 flask-cors

---

## 11. 可能的优化与扩展

- 算法层：
  - 负载均衡路径查找可替换为 Yen 的 K 最短路；分配可按最小化最大链路利用率的优化模型
  - 最大流可加入 ISAP、HLPP 等更高效实现作对比
- 可视化层：
  - 前端自绘最大流/层次图（SVG），减少后端图像生成时间
  - 大规模网络的虚拟化与渐进绘制
- 工程层：
  - TypeScript + 更严格的 schema 校验
  - 统一日志与性能埋点（记录算法时间、步数、可视化耗时）

---

## 12. 答辩要点与常见问答（Q&A）

### 12.1 算法相关

**Q1: 为什么同时实现 EK 与 Dinic？**

A: 便于对比“按边数最短增广 vs. 分层阻塞流”的两类思路；复杂度差异与实际表现对照直观。通过实际运行时间对比，可以验证理论复杂度分析。

**Q2: 交互式仿真是否等价于最大流？**

A: 否。仿真更强调“实时多路径与容量感知”的启发式分配，便于演示“拥塞/利用率/动画”等交互效果。最大流算法追求全局最优解，而交互仿真更注重过程可视化和动态调整。

**Q3: 负载均衡为什么按“瓶颈容量比例”分配？**

A: 简单、稳定、可解释。保证各路径不超过自身瓶颈且总流量不超总容量，适合教学演示。实际应用中可扩展为数值优化求解（如线性规划）以获得更优解。

### 12.2 实现相关

**Q4: 可视化如何保证连贯与可读？**

A: 采用多种技术保证：
- 固定布局种子避免节点抖动
- 为“初始化/路径/层次/结束”关键节点制作帧
- 颜色语义一致（绿/红/蓝等）
- 前端支持放大与逐帧播放
- 高清图像输出（150 DPI）

**Q5: 随机拓扑生成如何保证“连通 + 近似平面”？**

A: 采用两阶段生成策略：
1. 先生成生成树保证连通
2. 尝试添加边并用 NetworkX 的 check_planarity 校验平面性
3. 节点坐标采用极坐标随机布置 + 最小间距约束
4. 自动调整直到满足条件

**Q6: 为什么选择 80% 作为拥塞阈值？**

A: 80% 是网络工程中的经验值：
- 50-80%：链路正常运行区间
- 80-95%：高负载区间，应避免新流量
- >95%：接近饱和，强制需找其他路径
此阈值可以在代码中灵活配置。

### 12.3 性能相关

**Q7: 为什么将算法计时与可视化计时分开？**

A: 为了准确衡量算法性能：
- 纯算法时间：只包含核心计算逻辑
- 可视化时间：包括图像生成、Base64编码等
- 总时间 = 算法时间 + 可视化时间
这样可以公平对比不同算法的性能。

## 13. 项目总结与展望

### 13.1 项目成果

1. **完整的算法实现**：所有核心算法均为自实现，代码清晰易读
2. **可视化教学工具**：适合课堂演示和学生实验
3. **性能对比平台**：准确的算法性能测试
4. **交互式仿真**：实时网络流量可视化
5. **完善的文档**：API、组件、算法均有详细说明

### 13.2 技术亮点

- 前后端分离架构，清晰的模块划分
- 双端可视化：服务端 Matplotlib + 客户端 SVG
- 智能路径选择：利用率阈值 + 动态权重调整
- 实时动画效果：SVG + CSS 动画
- 性能优化：计时分离、内存管理

### 13.3 后续优化方向

**算法层面：**
- 更多算法实现：ISAP、HLPP 等高级最大流算法
- 路径优化：Yen 的 K 最短路径算法
- 数值优化：基于线性规划的流量分配

**可视化层面：**
- 前端自绘最大流图，减少后端负载
- 3D 可视化：Three.js 实现立体网络
- 大规模网络支持：虚拟化渲染

**功能扩展：**
- 用户认证和数据存储
- 分布式网络仿真
- 实时协作功能
- 网络拓扑导入/导出

**工程化：**
- TypeScript 改造，增强类型安全
- 单元测试和集成测试
- Docker 容器化部署
- CI/CD 流水线

### 13.4 应用场景

1. **教学场景**：算法课程演示、实验作业
2. **研究场景**：网络算法性能对比、新算法验证
3. **工程场景**：网络容量规划、拥塞分析
4. **竞赛场景**：算法竞赛训练、题解可视化

---

## 14. 参考文献

1. Cormen, T. H., et al. (2009). *Introduction to Algorithms* (3rd ed.).
2. Kleinberg, J., & Tardos, E. (2005). *Algorithm Design*.
3. NetworkX Documentation: https://networkx.org/
4. Vue 3 Documentation: https://vuejs.org/
5. Flask Documentation: https://flask.palletsprojects.com/

---

---

## 13. 附：关键文件索引

- 后端：backend/app.py、algorithms/maxflow.py、algorithms/mst.py、algorithms/traffic.py、algorithms/generate_graph.py、algorithms/utils.py、config/network_config.py
- 前端：src/App.vue、src/components/*.vue、src/api/backend.js

（完）
