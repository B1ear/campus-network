<template>
  <div class="panel">
    <h2>💧 最大流算法</h2>
    <div class="layout">
      <div class="section">
        <h3>输入数据</h3>
        <label>节点 (逗号分隔):</label>
        <input v-model="nodes" placeholder="1,2,3,4" />
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
          <div><label>源点:</label><input v-model.number="source" type="number" placeholder="1" /></div>
          <div><label>汇点:</label><input v-model.number="sink" type="number" placeholder="4" /></div>
        </div>
        <label>边 (格式: from-to-capacity):</label>
        <textarea v-model="edges" rows="6" placeholder="1-2-16&#10;1-3-13"></textarea>
        <div style="display: flex; gap: 1rem; margin: 1rem 0;">
          <label><input type="radio" v-model="algo" value="edmonds-karp" /> Edmonds-Karp</label>
          <label><input type="radio" v-model="algo" value="dinic" /> Dinic</label>
        </div>
        <button @click="calc" :disabled="loading">{{ loading ? '计算中...' : '计算最大流' }}</button>
        <button @click="loadConfiguredNetwork" style="background: #10b981; color: white;">加载配置网络</button>
        <button @click="example" style="background: #eee; color: #666;">示例数据</button>
      </div>
      <div class="section">
        <h3>结果</h3>
        <div v-if="error" style="padding: 1rem; background: #fee; border-radius: 6px; color: #c33;">{{ error }}</div>
        <div v-if="result">
          <div style="padding: 1rem; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border-radius: 6px; margin-bottom: 1rem;">
            <div>算法: {{ result.algorithm }}</div>
            <div style="font-size: 1.5rem; font-weight: bold;">最大流: {{ result.max_flow }}</div>
            <div style="font-size: 0.9rem; opacity: 0.9;">源点: {{ result.source }} | 汇点: {{ result.sink }}</div>
          </div>
          
          <!-- 可视化图片 -->
          <div v-if="result.visualization" style="margin-bottom: 1.5rem; background: #f9f9f9; border: 2px solid #e0e0e0; border-radius: 8px; padding: 1rem;">
            <h4 style="margin-top: 0;">算法可视化:</h4>
            <img :src="'data:image/png;base64,' + result.visualization" alt="最大流可视化" style="max-width: 100%; height: auto; border-radius: 4px;" />
          </div>
          
          <h4>流量分配:</h4>
          <div v-for="(e, i) in result.flow_edges" :key="i" style="padding: 0.5rem; background: #f5f5f5; margin: 0.5rem 0; border-left: 4px solid #667eea; border-radius: 4px;">
            {{ e.from }} → {{ e.to }} <span style="color: #764ba2; font-weight: bold;">流量: {{ e.flow }}</span>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, computed, onMounted, inject } from 'vue'
import { api } from '../api/backend.js'
const nodes = ref('1,2,3,4')
const edges = ref('1-2-16\n1-3-13\n2-3-10\n2-4-12\n3-2-4\n3-4-14')
const source = ref(1)
const sink = ref(4)
const algo = ref('edmonds-karp')
const loading = ref(false)
const result = ref(null)
const error = ref(null)

// 获取全局网络配置
const globalNetwork = inject('globalNetwork', null)

onMounted(() => {
  // 不再自动加载，由用户手动点击“加载配置网络”按钮
  // loadNetworkFromStorage()
})
const parseNodes = computed(() => nodes.value.split(',').map(n => parseInt(n.trim())).filter(n => !isNaN(n)))
const parseEdges = computed(() => edges.value.split('\n').map(line => {
  const p = line.trim().split('-')
  if (p.length === 3) return { from: parseInt(p[0]), to: parseInt(p[1]), capacity: parseInt(p[2]) }
  return null
}).filter(e => e))
async function calc() {
  error.value = null; result.value = null; loading.value = true
  try {
    const n = parseNodes.value; const e = parseEdges.value
    if (!n.length || !e.length) throw new Error('请输入有效数据')
    if (!n.includes(source.value) || !n.includes(sink.value)) throw new Error('源点和汇点必须在节点列表中')
    result.value = algo.value === 'edmonds-karp' ? await api.maxflowEdmondsKarp(n, e, source.value, sink.value) : await api.maxflowDinic(n, e, source.value, sink.value)
  } catch (err) { error.value = err.message } finally { loading.value = false }
}
function example() { nodes.value = '1,2,3,4,5,6'; edges.value = '1-2-16\n1-3-13\n2-3-10\n2-4-12\n3-2-4\n3-5-14\n4-3-9\n4-6-20\n5-4-7\n5-6-4'; source.value = 1; sink.value = 6 }

function loadNetworkFromStorage() {
  try {
    const data = localStorage.getItem('campus-network-data')
    if (data) {
      const network = JSON.parse(data)
      console.log('加载的网络数据:', network)
      // 转换为面板格式
      nodes.value = network.nodes.map(n => n.id).join(',')
      edges.value = network.edges.map(e => `${e.from}-${e.to}-${e.capacity}`).join('\n')
      // 设置默认源点和汇点
      if (network.nodes.length > 0) {
        source.value = network.nodes[0].id
        sink.value = network.nodes[network.nodes.length - 1].id
      }
      return true
    }
    return false
  } catch (err) {
    console.error('加载网络数据失败:', err)
    return false
  }
}

function loadConfiguredNetwork() {
  const loaded = loadNetworkFromStorage()
  if (loaded) {
    error.value = null
    console.log('网络配置已加载')
  } else {
    error.value = '未找到配置的网络，请先在“网络配置”标签页生成并应用网络'
  }
}
</script>

<style scoped>
.panel { padding: 1rem; } .layout { display: grid; grid-template-columns: 1fr 1fr; gap: 2rem; }
.section { display: flex; flex-direction: column; gap: 0.75rem; }
h2 { color: #667eea; margin: 0 0 1rem; } h3 { color: #333; border-bottom: 2px solid #667eea; padding-bottom: 0.5rem; margin: 0; }
label { font-weight: 600; color: #555; font-size: 0.9rem; }
input, textarea { padding: 0.6rem; border: 2px solid #ddd; border-radius: 6px; font-size: 1rem; font-family: inherit; }
input:focus, textarea:focus { outline: none; border-color: #667eea; }
button { padding: 0.75rem; border: none; border-radius: 6px; font-weight: 600; cursor: pointer; background: #667eea; color: white; font-size: 1rem; }
button:hover:not(:disabled) { background: #5568d3; } button:disabled { opacity: 0.6; cursor: not-allowed; }
@media (max-width: 900px) { .layout { grid-template-columns: 1fr; } }
</style>
